1a) A Programação Orientada a Objetos (POO) é um estilo de programação que se concentra em "objetos" que possuem tanto dados quanto comportamentos.
Esses objetos são criados a partir de modelos chamados de classes. POO destaca três princípios-chave: encapsulamento, herança e polimorfismo.

Exemplo: 

#include <iostream>
#include <string>

using namespace std;

class Carro {
public:
    string marca;
    string modelo;

    void dirigir() {
        cout << "O " << marca << " " << modelo << " está em movimento." << endl;
    }
};

int main() {
    Carro meuCarro;

    meuCarro.marca = "Toyota";
    meuCarro.modelo = "Corolla";

    meuCarro.dirigir();

    return 0;
}

1b) Classe é uma estrutura de programação que encapsula dados para o estado e comportamentos para manipular esses dados.
Ela serve como um modelo ou plano para criar objetos que compartilham características comuns.
Ex:

class Carro:
    marca = ""
    modelo = ""
    
    def dirigir(self):
        print("O carro está em movimento.")

    def definir_carro(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

1c) Uma instância refere-se a um objeto específico criado a partir de uma classe.
 Ex: 

#include <iostream>
#include <string>

using namespace std;

class Carro {
public:
    string marca;
    string modelo;
};

int main() {
    Carro meu_carro;
    
    meu_carro.marca = "Toyota";
    meu_carro.modelo = "Corolla";
    
    cout << "Meu carro é um " << meu_carro.marca << " " << meu_carro.modelo << "." << endl;
    
    return 0;
}

1d) Um objeto é uma instância particular de uma classe que contém dados e comportamentos associados a esse tipo de entidade.
Ex:

#include <iostream>
#include <string>

using namespace std;

class Carro {
public:
    string marca;
    string modelo;
};

int main() {
    Carro meu_carro;
    
    meu_carro.marca = "Toyota";
    meu_carro.modelo = "Corolla";
    
    cout << "Meu carro é um " << meu_carro.marca << " " << meu_carro.modelo << "." << endl;
    
    return 0;
}

2) Por padrão, os membros de uma struct são públicos, enquanto os membros de uma class são privados.

3) Atributos são as características ou dados que pertencem a um objeto de uma classe, enquanto métodos são as funções que definem o comportamento
ou as operações que o objeto pode realizar.



4) C

5) Herança permite que uma classe herde atributos e métodos de outra classe, enquanto o polimorfismo 
permite que diferentes objetos sejam tratados de maneira uniforme através de uma interface comum.

6) O encapsulamento, usando modificadores de visibilidade como +publico (público), -privado (privado) e #protegido (protegido),
protege os dados da classe, controlando seu acesso e garantindo a integridade do sistema.

7) São utilizados para acessar e modificar os atributos de uma classe de forma controlada, encapsulando o acesso aos dados.
Ex: 

#include <iostream>
using namespace std;

class Pessoa {
private:
    string nome;
    int idade;
    char sexo;

public:
    string getNome() { return nome; }
    void setNome(string n) { nome = n; }

    int getIdade() { return idade; }
    void setIdade(int i) { idade = i; }

    char getSexo() { return sexo; }
    void setSexo(char s) { sexo = s; }
};

int main() {
    Pessoa pessoa;
    pessoa.setNome("Joao");
    pessoa.setIdade(25);
    pessoa.setSexo('M');
    cout << "Nome: " << pessoa.getNome() << endl;
    cout << "Idade: " << pessoa.getIdade() << endl;
    cout << "Sexo: " << pessoa.getSexo() << endl;
    return 0;
}

8) é um conceito que permite uma classe herdar atributos e métodos de outra classe, promovendo reutilização 
de código e permitindo extensões e especializações.

9) #include <iostream>
#include <string>

using namespace std;

int main() {
    const int MAX_ALUNOS = 100;
    string nomes[MAX_ALUNOS];
    int matriculas[MAX_ALUNOS];
    int idades[MAX_ALUNOS];
    int semestres[MAX_ALUNOS];
    string cursos[MAX_ALUNOS];

    int quantidadeAlunos = 0;

    int opcao;
    do {
        cout << "\nMenu:\n1. Cadastrar Aluno\n2. Listar Alunos\n3. Sair\nEscolha uma opcao: ";
        cin >> opcao;
        cin.ignore();

        switch (opcao) {
            case 1:
                if (quantidadeAlunos < MAX_ALUNOS) {
                    cout << "Digite o nome do aluno: ";
                    getline(cin, nomes[quantidadeAlunos]);

                    cout << "Digite a matricula do aluno: ";
                    cin >> matriculas[quantidadeAlunos];

                    cout << "Digite a idade do aluno: ";
                    cin >> idades[quantidadeAlunos];

                    cout << "Digite o semestre do aluno: ";
                    cin >> semestres[quantidadeAlunos];
                    cin.ignore();

                    cout << "Digite o curso do aluno: ";
                    getline(cin, cursos[quantidadeAlunos]);

                    quantidadeAlunos++;
                    cout << "Aluno cadastrado com sucesso!" << endl;
                } else {
                    cout << "Limite de alunos atingido!" << endl;
                }
                break;
            case 2:
                cout << "Lista de Alunos:" << endl;
                for (int i = 0; i < quantidadeAlunos; i++) {
                    cout << "Nome: " << nomes[i] << endl;
                    cout << "Matricula: " << matriculas[i] << endl;
                    cout << "Idade: " << idades[i] << endl;
                    cout << "Semestre: " << semestres[i] << endl;
                    cout << "Curso: " << cursos[i] << endl;
                    cout << "-----------------------------" << endl;
                }
                break;
            case 3:
                cout << "Encerrando o programa." << endl;
                break;
            default:
                cout << "Opcao invalida. Tente novamente." << endl;
        }
    } while (opcao != 3);

    return 0;
}


